OopDesc： java对象在jvm的存在形式
	MarkOopDesc ： 存放锁信息、分代年龄·····
	InstanceOopDesc： 非数组对象
	ArrayOopDesc： 数组对象
		typeArrayOopDesc： 基本类型数组
		objectArrayOopDesc； 引用类型数组


HSDB中 _layout_helper
1、如果是非数组对象，这个值就是类生成的对象大小
2、如果是数组对象，负数
3、==0

对象的内存结构（对象在内存中的布局）：
	对象头：
		Mark Word： 32bit下占4字节，64bit下占8字节
			哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为“Mark Word”

		类型指针（Klass Pointer）：对象所属的类的元信息的实例（instanceKlass在内存中的地址）
			指针压缩： 开启 4字节  关闭 8字节
		数组长度： 4字节
			如果对象不是数组，0字节
			如果是，4字节
			数组最多有2的32次方-1
	实例数据：
	对其填充：
		8字节对齐
		由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。
		总的一句话来说，“数据项仅仅能存储在地址是数据项大小的整数倍的内存位置上（分别为偶地址、被4整除的地址、被8整除的地址）”比如int类型占用4个字节，地址仅仅能在0，4，8等位置上。

JDK6以后指针压缩默认开启
-XX:-UseCompressedOops -表示关闭，+表示开启
需要maven包  jol-core

没实例数据的对象：
	开启指针压缩：
		16B = 8B + 4B + 0 + 0 + 4B
		对象大小 = MarkWord + KlassPointer + 实例数据 + 数组长度 + 对其填充
	关闭指针压缩：
		16B = 8B + 8B + 0 + 0 + 0
普通对象：
	有2个int类型属性

	开启指针压缩：
		24B = 8B + 4B + 0 + 4 * 2 + 4B
	关闭指针压缩：
		24B = 8B + 8B + 0 + 4B * 2 + 0 

数组对象：
	对象有一个数组属性

	开启指针压缩：
		32B = 8B + 4B + 4B + 4B * 3 + 4B
	关闭指针压缩：

		数组对象在关闭指针压缩的情况下会出现两段填充
		40B = 8B + 8B + 4B + 4B + 4B * 3 + 4B

指针压缩的实现原理：
	存储的时候，后三位抹零， 因为对象大小都是8的倍数， 最后三位都是000， 寻址更高效

一个OOP能表示的最大堆空间  2的35次方  32G

32G不够用，怎么扩容？
	将8字节对齐改为16字节对齐 32G * 2 = 64G
	java中所有的对象都是16字节对齐

JVM调优
1、项目未上线前做预估调优
2、项目上线初期，基于日志做一些基础调优
3、发生OOM、频繁FullGC，做彻底调优

调优
1、JVM内存模型调优
2、热点代码缓冲区调优