两种解释器：
	字节码解释器
		字节码 -> c++ -> 硬编码

	模板解释器
		字节码 -> 硬编码

		原理：
			1、申请一块可读可写可执行的内存
			2、将处理NEW字节码的硬编码拿过来（llbd 解析可执行文件）
			3、将处理NEW字节码的硬编码写入之前申请的内存
			4、申请一个函数指针，用这个函数指针指向这块内存
			5、直接通过函数指针调用


三种运行模式：
	1、-Xint 纯字节码解释器
	2、-Xcomp 纯模板解释器
	3、-Xmixed 字节码+模板

	性能排序： 321 或者 231


字节码解释器是解释执行，跟即时编译器无关。


即时编译器：
	C1
		C1编译器是client模式下的即时编译器
		1、触发的条件相对C2比较宽松，需要收集的数据较少
		2、编译优化比较浅
		3、C1编译器编译生成的代码执行效率比C2低

	C2
		C2编译器是Server模式下的即时编译器
		1、触发的条件比较严格，一般来说程序运行了一段时间以后才会触发
		2、编译优化深
		3、生成的代码执行效率高

	混合编译
		程序运行初期是C1编译器，运行一段时间后变为C2编译器

即时编译的组小单位不是一个函数，而是代码块（for、while代码块）

	Client编译器模式下，N的默认值是1500
	Server编译器模式下，N的默认值是10000

	java -client -XX:+PrintFlagsFinal -version | grep CompileThreshold


	热点代码缓存在方法区