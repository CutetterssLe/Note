Redis常用的5种数据类型：
    1、String：SDS
    2、List：zipList压缩列表 + linkedList双端链表
    3、Set：intset整数集合 + HashTable哈希表
    4、Hash：HashTable哈希表 + zipList压缩列表
    5、ZSet：skipList跳跃链表 + zipList压缩列表
    后续又丰富了几种：Bitmaps、HyperLogLogs、GEO
-----------------------------------------------------------------------------
Redis底层数据结构：
    SDS（简单动态字符串）
    链表
    字典
    跳表
    整数集合
    压缩列表
    对象
-----------------------------------------------------------------------------
SDS相比于C语言中字符串的优势：
    1、O(1)的时间复杂度获取字符串长度 ：C字符串需要遍历而sds中有len可以直接获得。 
    2、防止缓冲区溢出bufferoverflow：当sds需要对字符串进行修改时，首先借助于len和alloc检查空间是否满足修改所需的要求，
        如果空间不够的话，SDS会自动扩展空间，避免了像C字符串操作中的覆盖情况；
    3、有效降低内存分配次数：C字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配、sds使用了空间预分配和惰性空间释放机制，
        说白了就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给OS。
    4、二进制安全：C语言字符串只能保存ascii码，对于图片、音频等信息无法保存，sds是二进制安全的，写入什么读取就是什么，
        不做任何过滤和限制

    C语言中使用N+1长度的字符串数组来表示字符串，尾部使用'\0'作为结尾标志
    SDS分为三部分：
        1、Header：包括 len、alloc、flags
        2、buff
        3、结尾为null
-----------------------------------------------------------------------------
Redis字典（可以基于zipLis 或者 HashTable实现，只讨论hashtable哈希表）：
    dictEntry（哈希节点） -> dictht（哈希表） -> dict（字典）
    （dictType函数指针簇  rehashidx渐进式标记）
    //伪码：使用哈希函数，计算键key的哈希值
    hash = dict->type->hashFunction(key);
    //伪码：使用哈希表的sizemask和哈希值，计算出在ht[0]或许ht[1]的索引值
    index = hash & dict->ht[x].sizemask;    
-----------------------------------------------------------------------------
渐进式Rehash：
    哈希表保存的键值对数量是动态变化的，为了让哈希表的负载因子维持在一个合理的范围之内，就需要对哈希表进行扩缩容。
    扩缩容是通过执行rehash重新散列来完成，对字典的哈希表执行普通rehash的基本步骤为：
        1、分配空间：创建ht[1]哈希表，分配至少ht[0].userd * 2 的最近的一个 2^n 大小空间（used = 3，3 * 2 = 6 最近的是2^3）
        2、逐个迁移：将ht[0]的键值对重新计算键的hash和索引值reshash到ht[1]
        3、交换哈希表：迁移完成后，将ht[1]设置为ht[0]，并在ht[1]处创建新的hash表，便于下一次reahsh
    渐进式rehash过程（普通rehash会一次性将ht[0]迁移至ht[1]，容易造成服务器堵塞）：
        1、分配空间：和普通rehash没区别
        2、将rehashidx设置为0，表示rehash工作正式开始，idx自增
        3、在rehash期间，如果对字典执行CRUD操作，会将ht[0]哈希表在rehashidx索引上的键值对rehash到ht[1]，然后将
            idx + 1，指向下一个需要rehash的键值对
        4、等待rehash完毕后，将idx设置为 -1， 表示完成
-----------------------------------------------------------------------------        
Redis单线程模式：
    Redis并不是单纯的单线程服务模型，一些辅助工作比如持久化刷盘、惰性删除等任务是由BIO线程来完成的。
    与客户端交互的线程是单线程。
    多线程主要是充分利用CPU性能，Redis操作内存，处理极快，内存才是瓶颈。
    Redis有复杂的KV数据结构，如果采用多线程去操作key，就会要加锁来进行同步，可能造成死锁。（可以对key进行hash以及多线程的负载均衡处理）
-----------------------------------------------------------------------------
Redis的文件事件和时间事件：
    Redis是事件驱动的服务器。
    时间事件：
        1、定时事件：任务在等待指定大小的等待时间之后就执行，执行完成就不再执行，只触发一次
        2、周期事件：任务每隔一定时间就执行，执行完成之后等待下一次执行，会周期性的触发
            Redis中大部分都是周期事件，定期对服务器进行健康检查，保证稳定性，主要是ServerCron函数来完成。
            1、删除数据库的key
            2、触发RDB和AOF持久化
            3、主从同步
            4、集群保活
            5、关闭清理死客户端链接
            6、统计服务器的内存、key数量等信息

        时间事件的无序链表分为三部分：
            1、事件全局ID
            2、触发事件的ms精度
            3、事件处理函数、回调函数