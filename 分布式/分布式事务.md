## 典型的分布式事务
- 跨库事务
- 分库分表
- 微服务架构下，跨服务调用

## 1、刚性分布式事务

        数据状态强一致，系统支持并发低，事务执行时间较短，属于短事务，所有数据在事务内进行。
        遵循XA协议，通过实现XA的接口来实现分布式事务。
        XA规范由AP（定义事务的开始和结束，并访问事务内的资源）、RM（通常指的就是数据库资源）、TM（负责管理事务，分配事务的唯一标识、监控事务的执行情况、并负责事务的提交、回滚等操作）组成
- 两阶段提交2PC
 
    AP向TM发起commit请求，TM向RM发送prepare，当TM收到所有的RM返回的ok消息后，TM再向所有的RM发送commit指令，待收到所有的RM返回的ok消息后，commit才算完成。在prepare阶段，当有一个RM返回失败的时候，则不能进行第二步的commit操作，TM释放所有占用的资源；在commit阶段，当有一个RM返回失败时，则TM都要协调commit进行补偿，保证所有提交到RM的commit请求，要么都成功、要么都失败。
  - 缺点
    - 同步阻塞
    - TM瓶颈
    - RM锁定资源时间过长
    - 全局锁定，不适合长事务，并发低

- 3PC
  
  CanCommit：TM向所有RM发出CanCommit指令，RM收到指令后，判断可否提交事务，如果可以返回ok，否则返回no；

  PreCommit：当TM收到所有RM都返回CanCommit的结果为ok时，TM向所有RM发出PreCommit；当有一个RM返回no或超时，导致TM没收到反馈则事务中断，TM向所有RM发出abort终止事务，TM收到abort后终止事务，释放资源。如果RM没收到TM发出的abort或是超时，则RM也会中断自身的事务，释放资源；

  DoCommit：TM收到所有RM都返回PreCommit的结果为ok时，TM向所有RM发出DoCommit，执行事务真正的提交，TM收到所有RM的DoCommit的执行结果为ok时，
  释放所占用的所有资源；当有一个RM返回no或超时，导致TM没收到反馈则事务中断，TM向所有RM发出abort终止事务，各个RM收到abort后利用CanCommit阶段的Undo信息执行回滚操作，释放占用的资源；但是，如果RM没收到TM发出的abort或是超时后，则RM会继续提交事务，这将导致数据的不一致。
  

        三阶段相比两阶段，优点有：降低阻塞范围；TM瓶颈问题得到部分解决，即在第一二阶段时，当超时的时候RM会自动释放资源，不依赖TM。但进入第三阶段后，如果超时则不会释放资源，而会继续提交事务，这种情况下，将导致数据的不一致。
## 2、柔性分布式事务
柔性分布式事务是相对刚性分布式事务、是对强一致性的妥协，从而降低对数据库资源的锁定时间，提升系统的性能。柔性分布式事务适合于长事务、高并发，强调最终一致性的场合。常用的实现柔性分布式事务的方式有：TCC模型、Saga模型、基于消息队列的异步模型。
### 2.1 TCC模型
TCC是一个两阶段提交（2PC）的实现，每一个业务都需要实现Try-Confirm-Cancel三个接口，Try是尝试执行业务，完成所有业务执行前的检查；Confirm是真正执行业务，提交事务，释放资源；Cancel是业务失败的时候回滚业务操作，释放资源。

TCC模型的实现是分为2步操作完成一次事务操作，达到最终事务的一致性。
### 2.2 Saga模型
起源于1987年Hector Garcia-Molina和Kenneth Salem发表的论文《Sagas》,主要思想是把一个分布式事务拆分为多个本地事务，每一个本地事务都有相应的正常执行方法和异常补偿方法，当任意一个本地事务出错时，都可以通过调用相应的异常补偿方法恢复之前的事务或是继续执行未完成的事务，保证事务的最终一致性。
### 2.3 基于消息队列的模型
目前基于消息队列的异步模型，其实现方式有多种，在这里我列出两种进行介绍，一种是业务方提供本地操作成功回查功能，一种是基于本地事务消息表。

在用消息队列处理的业务场景中，都存在发送方重复多次发送的可能，所以消费方都需要保证业务接口的幂等性，便于重复发送，重复消费时业务的幂等。消息队列在电商、互联网等业务中用的比较广泛，其作用主要体现在业务削峰，解耦业务，异步处理等场合。